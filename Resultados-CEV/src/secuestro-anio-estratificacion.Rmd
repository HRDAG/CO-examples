---
title: "Proceso estratificación para estimaciones"
subtitle: "Secuestros desagregado por año del hecho - 1990–2018"
output:
  rmdformats::robobook:
    code_folding: show
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    use_bookdown: true
    highlight: kate
    embed_fonts: false
---

```{r setup, echo = TRUE,include = FALSE}

pacman::p_load(ggplot2, dplyr, rmarkdown, verdata, LCMCR, here,
               arrow, dplyr, rlang, purrr, glue, tidyr, stringr, 
               gridExtra)

options(warn = -1)
```

```{r numbers, include = FALSE}

myNum <- function(n) {
  return(prettyNum(n, big.mark = " "))
}

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

```

```{r library, include=TRUE}

library(verdata)

```

## Introducción {-}

Si es su primera vez trabajando con los datos, no está muy familiarizado con el 
paquete o simplemente quiere conocer más sobre el proyecto y el objetivo de 
estos ejemplos y el paquete `verdata`, consulte:
https://github.com/HRDAG/CO-examples/blob/main/Introducción/output/Introducción.html 
antes de continuar. 

En este ejemplo se ilustrará el proceso de estratificación para el posterior 
proceso de estimación del total de víctimas por año del hecho (1990–2018).

## Autenticando e importando la base de datos (réplicas) {-}

Se comienza autenticando e importando la base de datos, esto a 
través de dos funciones del paquete `verdata`: las funciones `confirm_files` y 
`read_replicates`. La autenticación de los datos es pertinente dado que estos 
fueron publicados con la licencia de atribución 4.0 internacional de Creative 
Commons (CC BY 4.0). Esta licencia permite la distribución y modificación de la 
información. Considerando que usted pudo haber llegado a estos datos por medio 
de diferentes fuentes, es importante que sepa si han sido modificados o no, para 
lo que puede hacer uso de estas dos funciones. 

La función `confirm_files` autentica los archivos que han sido descargados. 
Considerando que cada violación tiene hasta 100 réplicas, esta función permite
autenticar cada uno de estos archivos sin necesidad de leerlos a R. Esto, en 
caso de querer ahorrar recursos computacionales, o en caso de que no vaya a 
realizar su análisis con todas las réplicas. Esta función devolvera el mensaje 
_"You have the right file!"_ si los archivos son iguales a los publicados, o 
el error _"This file is not identical to the one published. This means the results of the analysis may potentially be inconsistent."_ si no lo son. 

```{r confirm-replicates, eval=FALSE}

verdata::confirm_files(here::here("verdata-replicas/verdata-parquet"), 
                                  "secuestro", 1, 10)

```

Además, la función `read_replicates` permite 2 cosas: leer las réplicas a R en
una sola tabla (ya sea a partir de un formato *csv* o *parquet*) y verificar 
que el contenido de las réplicas sea exactamente igual al publicado.
Cuando el argumento `crash` tiene su valor por default (TRUE), la función 
retorna un objeto (data frame) si el contenido es igual, y el mensaje
_"The content of the files is not identical to the ones published. This means the results of the analysis may potentially be inconsistent."_ si el contenido de la base fue 
previamente alterado/modificada, lo que quiere decir que los análisis que el 
usuario realice hacer serán inconsistentes y llevarán a resultados erróneos. 
Este último error significa que nos datos no se han leído a R. Si por alguna 
razón, usted quiere leer los datos a pesar de saber que no son los mismos datos 
originamente publicados, puede cambiar el argumento `crash` a FALSE, y, 
en ese caso, podrá ver los datos, junto con el mismo mensaje de advertencia. 

```{r open-replicates, echo = TRUE}

replicas_datos <- verdata::read_replicates(here::here("verdata-replicas/verdata-parquet"),
                                           "secuestro", 1, 10)

paged_table(replicas_datos, options = list(rows.print = 10, cols.print = 5))

```

Vemos que tenemos `r myNum(nrow(replicas_datos))` registros, nuestras réplicas 
van desde la número 1 hasta la 10. Además, nuestros datos tienen información 
sobre la categoría de edad de la víctima, el presunto perpetrador, el sexo, 
el año del hecho, la pertenencia étnica, entre otros. 
Sin embargo, para centrarnos en un análisis más específico, tal como el realizado
para el informe metodológico, procederemos a transformar y/o filtrar 
algunas variables. 

## Filtrando las réplicas acorde con el filtro del informe metodológico {-}

La función `filter_standard_cev` nos permite transformar o filtrar nuestra
información.

```{r filter-cev, echo = TRUE}

replicas_filtradas <- verdata::filter_standard_cev(replicas_datos,
                                                   "secuestro", 
                                                   perp_change = TRUE) %>% 
  dplyr::mutate(is_conflict = as.integer(is_conflict)) %>%
  dplyr::filter(is_conflict == 1)

paged_table(replicas_filtradas, options = list(rows.print = 10, cols.print = 5))

```
Como vemos, el primer proceso fue filtrar nuestros datos según nuestro interés. 
Seguido de esto procedemos a estratificar. Es importante que usted como usuario
vea que este proceso es netamente artesanal, es decir, usted puede usar 
su propio código o funciones para realizar este proceso que, en nuestro caso, 
será a través de una función previamente creada (fuera del paquete `verdata`)
para facilitar este ejercicio:

```{r stratify, echo = TRUE}

stratify <- function(replicate_data, schema) {
    
    schema_list <- unlist(str_split(schema, pattern = ","))
    
    grouped_data <- replicate_data %>%
        group_by(!!!syms(schema_list))
    
    stratification_vars <- grouped_data %>%
        group_keys() %>%
        group_by_all() %>%
        group_split()
    
    split_data <- grouped_data %>%
        group_split(.keep = FALSE)
    
    return(list(strata_data = split_data,
                stratification_vars = stratification_vars))
    
}

```

Entonces, en primera instancia creamos una función que necesita de dos (2) 
argumentos:

- La primera está relacionada con los *datos* que en nuestro caso son
las **replicas_filtradas**.

- La segunda son nuestras variables de estratificación (`schema`).

En términos generales, lo que hace esta función es: primero agrupa por nuestras 
variables de estratificación y guarda esta información en un objeto llamado 
`grouped_data`; también definimos el nombre de nuestra estratificación.
Luego, `split_data` va a dividir nuestros datos previamente agrupados 
(en `group_data`) retornando una lista: `strata_data` que será los subconjuntos
de datos de acuerdo con la estratificación y `stratification_vars` que contiene 
las combinaciones (nombres) de nuestras variables. Sin embargo, es importante
aclarar que este ejercicio se realiza para cada réplica, por lo que aplicaremos
algo denominado "iteración", es decir, repetir el proceso varias veces
(por réplica). Esto lo veremos con más detalle a continuación:

```{r stratify-continuacion, echo = TRUE}

replicas <- paste0("R", 1:10)
resultados <- list()

for (replica in replicas) {
  strata_data <- replicas_filtradas[replicas_filtradas$replica == replica, ]
  
  var <- "sexo"
  strata <- stratify(strata_data, c("yy_hecho", var, sep = ","))
  
  resultados[[replica]] <- strata
}

```

```{r stratify-continuacion2, echo = TRUE}

replica4_grupo4 <- resultados[["R4"]][["strata_data"]][[4]]

paged_table(replica4_grupo4, options = list(rows.print = 10, cols.print = 5))

```
```{r stratify-continuacion3, echo = TRUE}

replica4_grupo4_estrato <- resultados[["R4"]][["stratification_vars"]][[4]]

paged_table(replica4_grupo4_estrato, options = list(rows.print = 10, cols.print = 5))

```

Acorde con lo visto en estos códigos, definimos nuestras variables de estratificación,
estratificamos nuestros datos filtrados (mostrando algo como unas "mini-bases" 
de datos, como la réplica 4) y por último definimos los nombres de esas agrupaciones
las cuales muestran todas las combinaciones entre estas dos variables (por ejemplo
lo que muestra *replica4_grupo4_estrato*).

Teniendo esta estratificación procederemos a guardar el objeto `results` en 
nuestra maquina local (con la función `saveRDS`) para usarlo en nuestro próximo 
ejemplo sobre estimación por sistemas múltiples (ESM):

```{r save-estratify, echo = TRUE}

saveRDS(resultados,
        here::here("Resultados-CEV/output-estratificacion/secuestro-yy_hecho-sexo.rds"))

```

El siguiente paso es realizar el proceso de [estimación y combinación](https://github.com/HRDAG/CO-examples/blob/main/Resultados-CEV/output/secuestro-anio-estimacion.html)
